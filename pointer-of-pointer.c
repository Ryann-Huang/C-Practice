#include <stdio.h>

int main(void) {
    int n = 0;
    int *p1 = &n;
    int **p2 = &p1;

    printf("n = %d\n", n);
    printf("address of n = %p\n", p1);
    printf("address of p1 = %p\n\n", p2);

    /* n 的型態是 int，&n 取得的值型態是 int*，因此指定 int* 型態的 p1，因為指標的宣告
       是 type *variable 嘛！p1 的 type 是 int*，自然地，能儲存 &p1 值的變數，就是宣告
       為 int* *p，只不過習慣上，宣告時會將 ** 排在一起，也才會有方才 int **p2 = &p1 的
       寫法，若要說 p2 的型態則是 int**。

       這個簡單的範例，只是用來理解想用指標儲存另一指標的位址時，型態上是怎麼宣告罷了，
       單純只是用指標來儲存另一個指標的位址，沒有太大的意義，重點在於指標的型態在運算時
       扮演的作用，例如〈指標與陣列〉中，對變數取址後遞增 1，目的是為了要位移一整個陣列
       空間：
       */
    int arr[] = {10, 20, 30, 40, 50};
    int len = *(&arr + 1) - arr;
    printf("arr[] length = %d\n", len);

    /* 一維陣列變數的元素位址可以儲至 int* 指標，那二維陣列呢？在〈二維（多維）陣列〉談
       過，多維陣列是由陣列的陣列構成，二維陣列可以看成數段一維陣列構成，必須宣告每段一
       維陣列的長度為何：
       */
    int arr1[2][3] = {{1, 2, 3}, {4, 5, 6}};
    int (*p3)[3] = arr1;

    /* 三維陣列可以看成數段三維陣列構成，因此必須宣告每段二維陣列的維度為何，例如： */
    int arr2[1][2][3] = {{{1, 2, 3}, {4, 5, 6}}};
    int (*p4)[2][3] = arr2;

    return 0;
}
